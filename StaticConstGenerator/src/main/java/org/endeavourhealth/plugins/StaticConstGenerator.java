package org.endeavourhealth.plugins;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.internal.impldep.org.apache.commons.io.FileUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.StringJoiner;

public class StaticConstGenerator implements Plugin<Project> {

  public void apply(Project project) {
    VocabGeneratorExtension extension = project.getExtensions().create("staticConstGenerator", VocabGeneratorExtension.class);
    extension.getInputJson().convention("./vocab.json");
    extension.getJavaOutputFolder().convention("./");
    extension.getTypeScriptOutputFolder().convention("./");
    project.getTasks().register("staticConstGenerator", t -> t
      .doLast(s -> execute(
        project.getProjectDir().getAbsolutePath(),
        extension.getInputJson().get(),
        extension.getJavaOutputFolder().get(),
        extension.getTypeScriptOutputFolder().get())
      )
    );
  }

  public void execute(String baseDir, String jsonIn, String javaOut, String tsOut) {
    if (!baseDir.endsWith("/"))
      baseDir += "/";

    jsonIn = baseDir + jsonIn;
    javaOut = baseDir + javaOut;
    tsOut = baseDir + tsOut;

    try (InputStream in = new FileInputStream(jsonIn)) {

      ObjectMapper mapper = new ObjectMapper();
      List<VocabDef> defs = mapper.readValue(in, new TypeReference<>() {
      });

      for (VocabDef def : defs) {
        generateJava(javaOut, def);
        generateTypeScript(tsOut, def);
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private void generateJava(String javaOut, VocabDef def) {
    generateCode(
      def,
      javaOut + def.name.toUpperCase() + ".java",
      "    ",
      System.lineSeparator(),
      "{NAME}({VALUE}),",
      """
      // This file is autogenerated. Any edits made will be lost. To make changes go to imapi/api/vocab.json and re-run gradle task staticConstGenerator
      
      package org.endeavourhealth.imapi.vocabulary;
      
      import org.eclipse.rdf4j.model.IRI;
      import org.eclipse.rdf4j.model.util.Values;
      import org.endeavourhealth.imapi.model.tripletree.TTIriRef;
      
      import static org.endeavourhealth.imapi.model.tripletree.TTIriRef.iri;
        
      public enum {TYPE} implements VOCAB_ENUM {
      """,
      """
            ;
            
            private final String value;
        
            {TYPE}(final String value) {
                this.value = value;
            }
            
            {TYPE}(final VOCAB_ENUM value) {
                this.value = value.toString();
            }
        
            @Override
            public String toString() {
                return value;
            }
            
            public TTIriRef asIri() {
              return iri(value);
            }
            
            public IRI asDbIri() {
              return Values.iri(value);
            }
        }
        """
    );
  }

  private void generateTypeScript(String tsOut, VocabDef def) {
    generateCode(
      def,
      tsOut + def.name.toUpperCase() + ".ts",
      "  ",
      "\n",
      "public static readonly {NAME} = {VALUE}",
      """
        // This file is autogenerated. Any edits made will be lost. To make changes go to imapi/api/vocab.json and re-run gradle task staticConstGenerator
        
        export class {TYPE} {
        """,
      "}\n"
    );
  }

  private void generateCode(VocabDef def, String filename, String indent, String eol, String template, String header, String footer) {
    StringJoiner output = new StringJoiner(eol);

    output.add(header
      .replace("{TYPE}", def.name.toUpperCase()));

    if (def.entries != null && !def.entries.isEmpty()) {
      for (VocabDef.Entry entry : def.entries) {
        String name = entry.name;
        JsonNode value = entry.value;

        if (name == null || value == null)
          throw new IllegalArgumentException("Entry objects must have both a name and a value");

        if (!value.isTextual())
          throw new IllegalArgumentException("Unsupported type");

        output.add(indent + template
          .replace("{NAME}", name)
          .replace("{VALUE}", value.asText())
        );
      }
    }

    output.add(footer
      .replace("{TYPE}", def.name.toUpperCase()));

    writeIfChangedOrNotExists(filename, output.toString());
  }

  private void writeIfChangedOrNotExists(String filename, String output) {

    File f = new File(filename);

    try {
      String original = FileUtils.readFileToString(f, StandardCharsets.UTF_8);
      if (original.equals(output)) {
        // System.out.println(f.getName() + " unchanged...");
        return;
      }
      System.out.println(f.getName() + " changed, overwriting...");
    } catch (IOException e) {
      System.out.println(f.getName() + " does not exist, creating...");
    }

    try {
      Files.writeString(Paths.get(filename), output);
    } catch (IOException e) {
      System.err.println("Error writing output " + f.getName());
      System.exit(-1);
    }
  }
}
