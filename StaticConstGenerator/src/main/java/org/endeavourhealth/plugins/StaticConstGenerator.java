package org.endeavourhealth.plugins;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.internal.impldep.org.apache.commons.io.FileUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.StringJoiner;
import java.util.stream.Collectors;

public class StaticConstGenerator implements Plugin<Project> {

  public void apply(Project project) {
    VocabGeneratorExtension extension = project.getExtensions().create("staticConstGenerator", VocabGeneratorExtension.class);
    extension.getInputJson().convention("./vocab.json");
    extension.getJavaOutputFolder().convention("./");
    extension.getTypeScriptOutputFolder().convention("./");
    project.getTasks().register("staticConstGenerator", t -> t
      .doLast(s -> execute(
        project.getProjectDir().getAbsolutePath(),
        extension.getInputJson().get(),
        extension.getJavaOutputFolder().get(),
        extension.getTypeScriptOutputFolder().get())
      )
    );
  }

  public void execute(String baseDir, String jsonIn, String javaOut, String tsOut) {
    if (!baseDir.endsWith("/"))
      baseDir += "/";

    jsonIn = baseDir + jsonIn;
    javaOut = baseDir + javaOut;
    tsOut = baseDir + tsOut;

    try (InputStream in = new FileInputStream(jsonIn)) {

      ObjectMapper mapper = new ObjectMapper();
      List<VocabDef> defs = mapper.readValue(in, new TypeReference<>() {
      });

      for (VocabDef def : defs) {
        generateJava(javaOut, def);
        generateTypeScript(tsOut, def);
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private void generateJava(String javaOut, VocabDef def) {
    generateCode(
      def,
      javaOut + def.name + ".java",
      "    ",
      System.lineSeparator(),
      "{NAME}({VALUE}),",
      """
        // This file is autogenerated. Any edits made will be lost. To make changes, go to imapi/api/vocab.json and re-run gradle task staticConstGenerator
        
        package org.endeavourhealth.imapi.vocabulary;
        
        import com.fasterxml.jackson.annotation.JsonValue;
        import org.eclipse.rdf4j.model.IRI;
        import org.eclipse.rdf4j.model.util.Values;
        import org.endeavourhealth.imapi.model.tripletree.TTIriRef;
        
        import java.util.Arrays;
        import java.util.stream.Collectors;
        
        import static org.endeavourhealth.imapi.model.tripletree.TTIriRef.iri;
        
        public enum {TYPE} implements VocabEnum {
        """,
      """
            ;
        
            private final String value;
        
            {TYPE}(final String value) {
                this.value = value;
            }
        
            {TYPE}(final VocabEnum value) {
                this.value = value.toString();
            }
        
            @JsonValue
            @Override
            public String toString() {
                return value;
            }
        
            public TTIriRef asIri() {
              return iri(
                value, 
                Arrays.stream(this.name().split("_"))
                  .map(i -> i.substring(0, 1).toUpperCase() + i.substring(1).toLowerCase())
                  .collect(Collectors.joining(" "))
              );
            }
        
            public IRI asDbIri() {
              return Values.iri(value);
            }
        
            public static {TYPE} from(String text) {
              if (text == null)
                throw new IllegalArgumentException("no text specified");
                
              for ({TYPE} b : {TYPE}.values()) {
                if (b.value.equals(text)) {
                  return b;
                }
              }
              throw new IllegalArgumentException("no enums match text specified");
            }

        }
        """
    );
  }

  private void generateTypeScript(String tsOut, VocabDef def) {
    generateCode(
      def,
      tsOut + def.name + ".ts",
      "  ",
      "\n",
      "public static readonly {NAME} = {VALUE}",
      "import {{IMPORT}} from \"@/vocabulary/{IMPORT}\";",
      """
        // This file is autogenerated. Any edits made will be lost. To make changes, go to imapi/api/vocab.json and re-run gradle task staticConstGenerator
        
        {IMPORTS}
        
        export class {TYPE} {
        """,
      "}\n"
    );
  }

  private void generateCode(VocabDef def, String filename, String indent, String eol, String template, String header, String footer) {
    generateCode(def, filename, indent, eol, template, null, header, footer);
  }

  private void generateCode(VocabDef def, String filename, String indent, String eol, String template, String importTemplate, String header, String footer) {
    String imports = "";
    if (importTemplate != null && !importTemplate.isEmpty() && def.imports != null && !def.imports.isEmpty()) {
      imports = def.imports.stream().map(
        i -> importTemplate.replace("{IMPORT}", i)
      ).collect(Collectors.joining(eol));
    }

    StringJoiner output = new StringJoiner(eol);

    output.add(header
      .replace("{IMPORTS}", imports)
      .replace("{TYPE}", def.name)
    );

    if (def.entries != null && !def.entries.isEmpty()) {
      for (VocabDef.Entry entry : def.entries) {
        String name = entry.name;
        JsonNode value = entry.value;

        if (name == null || value == null)
          throw new IllegalArgumentException("Entry objects must have both a name and a value");

        if (!value.isTextual())
          throw new IllegalArgumentException("Unsupported type");

        output.add(indent + template
          .replace("{NAME}", name)
          .replace("{VALUE}", value.asText())
        );
      }
    }

    output.add(footer
      .replace("{TYPE}", def.name));

    writeIfChangedOrNotExists(filename, output.toString());
  }

  private void writeIfChangedOrNotExists(String filename, String output) {

    File f = new File(filename);

    try {
      String original = FileUtils.readFileToString(f, StandardCharsets.UTF_8);
      if (original.equals(output)) {
        return;
      }
      System.out.println(f.getName() + " changed, overwriting...");
    } catch (IOException e) {
      System.out.println(f.getName() + " does not exist, creating...");
    }

    try {
      Files.writeString(Paths.get(filename), output);
    } catch (IOException e) {
      System.err.println("Error writing output " + f.getName());
      System.exit(-1);
    }
  }
}
